<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optimizer Shell</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <h1>Core Allocation Optimizer</h1>

  <!-- ========== RESOURCE INPUTS ========== -->
  <section id="resources">
    <h2>Resources</h2>
    <label>EShards: <input type="number" id="eShards" value="0"></label>
    <label>VShards: <input type="number" id="vShards" value="0"></label>
    <label>RCores: <input type="number" id="relicCores" value="0"></label>
    <label>ACores: <input type="number" id="awakeningCores" value="0"></label>
    <label>SShards: <input type="number" id="sShards" value="0"></label>
  </section>

<!-- ========== COLLECTABLES ========== -->
<section id="resonanceInputs" class="section">
  <h2>Base Resonance</h2>

  <label for="baseResonanceA">Base Resonance (Drone / Force Field)</label>
  <input type="number" id="baseResonanceA" value="3000"><br>

  <label for="baseResonanceB">Base Resonance (Drill / Rocket)</label>
  <input type="number" id="baseResonanceB" value="3000"><br>

  <label for="baseResonanceC">Base Resonance (Durian / Soccer)</label>
  <input type="number" id="baseResonanceC" value="3000"><br>

  <label for="RChips">RChips:</label>
  <input type="number" id="RChips" value="3000">
</section>

<!-- ========== Parts Wieght System ========== -->
<section id="priorityInputs" class="section">
  <h2>Part Priority Weights <small>(higher = more important)</small></h2>

  <label for="priorityDrone">Drone / Force Priority</label>
  <input type="number" step="0.01" id="priorityDrone" value="1.7"><br>

  <label for="priorityDrill">Drill / Rocket Priority</label>
  <input type="number" step="0.01" id="priorityDrill" value="1.05"><br>

  <label for="priorityDurian">Durian / Soccer Priority</label>
  <input type="number" step="0.01" id="priorityDurian" value="0.4">
</section>

<!-- ========== Survivor Selector ========== -->
<section id="survivors" class="section">
  <h2>Survivor Setup</h2>

  <label for="survivorSelect">Select Survivor:</label>
  <select id="survivorSelect"></select>

  <div id="survivorDetails" style="margin-top: 20px; padding: 10px; background: #222; border: 1px solid #444; color: #eee;"></div>
</section>
<script src="survivors.js"></script>

<script>
  const survivorData = window.survivors || {};
  const selectEl = document.getElementById('survivorSelect');
  const detailsEl = document.getElementById('survivorDetails');

  // Populate dropdown
  Object.keys(survivorData).forEach(key => {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = survivorData[key].name || key;
    selectEl.appendChild(option);
  });

  selectEl.addEventListener('change', () => renderSurvivor(selectEl.value));

  function renderSurvivor(key) {
    const data = survivorData[key];
    if (!data) return detailsEl.innerHTML = '';

    const renderBlock = (title, obj) => {
      if (!obj) return '';
      const lines = Object.entries(obj).map(([k, v]) => `<div><strong>${k}:</strong> ${v}</div>`).join('');
      return `<h3>${title}</h3>${lines}`;
    };

    const renderCombatHarmony = (obj) => {
      if (!obj) return '';
      const blocks = Object.entries(obj).map(([k, v]) => `
        <div style="margin-left: 10px;">
          <strong>${k}:</strong> <br>
          <span>Yellow Stars: ${v.yellowStars}</span><br>
          <span>Red Left: ${v.redLeft}</span><br>
          <span>Red Right: ${v.redRight}</span><br>
          <span>Effect: ${v.effect}</span>
        </div>
      `).join('');
      return `<h3>Combat Harmony</h3>${blocks}`;
    };

    detailsEl.innerHTML = `
      ${renderBlock('Level Up', data.levelUp)}
      ${renderBlock('Upgrade', data.upgrade)}
      ${renderBlock('Awakening', data.awakening)}
      ${renderCombatHarmony(data.combatHarmony)}
    `;
  }

  // Load first survivor by default
  if (selectEl.options.length > 0) {
    renderSurvivor(selectEl.options[0].value);
  }
</script>


<!-- ========== Collectables Section ========== -->

<script src="collectables_with_rarity.js"></script>
<script src="collection_sets.js"></script>

<section>
  <h2>Collectables</h2>

  <div id="collectablesGrid" style="
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 10px;
  "></div>

  <pre id="collectableBonusOutput" style="background: #111; color: #0f0; padding: 10px; margin-top: 10px; white-space: pre-wrap;"></pre>
  <pre id="collectableSetDebug" style="background: #222; color: #0ff; padding: 10px; margin-top: 10px; white-space: pre-wrap;"></pre>
</section>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    const filteredCollectables = Object.entries(collectables)
      .filter(([_, data]) => data.rarity === "red" || data.rarity === "yellow")
      .slice(0, 56)
      .map(([name], index) => ({
        id: index + 1,
        name,
        icon: `icons/c${index + 1}.png`
      }));

    const levels = ["", "Y1", "Y2", "Y3", "Y4", "Y5", "R1", "R2", "R3", "R4", "R5"];
    const grid = document.getElementById('collectablesGrid');
    const bonusOutput = document.getElementById('collectableBonusOutput');

    function updateBonuses() {
      const bonusMap = {};
      const notes = [];

      const orderedStars = ["Y1", "Y2", "Y3", "Y4", "Y5", "R1", "R2", "R3", "R4", "R5"];
      const gridStats = new Set([
        "atk", "def", "hp",
        "critRate", "critDamage", "skillDamage",
        "bonusVsPoisoned", "bonusVsWeakened", "bonusVsChilled",
        "bonusVsLacerated", "bonusVsVulnerable", "bonusVsShielded"
      ]);
      const flatStats = new Set(["hpFlat", "atkFlat", "defFlat", "finalHP", "finalATK", "finalDEF"]);

      filteredCollectables.forEach(col => {
        const select = document.getElementById(`collectable${col.id}`);
        const selected = select.value;
        if (!selected) return;

        const entry = collectables[col.name];
        if (!entry || !entry.effects) return;

        const index = orderedStars.indexOf(selected);
        if (index === -1) return;

        const validStars = new Set(orderedStars.slice(0, index + 1));

        entry.effects.forEach(effect => {
          if (validStars.has(effect.star)) {
            if (effect.stat && typeof effect.value === "number") {
              bonusMap[effect.stat] = (bonusMap[effect.stat] || 0) + effect.value;
            }
            if (effect.note) {
              notes.push(`â€¢ ${col.name} (${effect.star}): ${effect.note}`);
            }
          }
        });
      });

      let output = "Total Collectable Bonuses:\n\n";
      if (Object.keys(bonusMap).length === 0 && notes.length === 0) {
        output += "No bonuses selected.";
      } else {
        const sorted = Object.entries(bonusMap).sort(([a], [b]) => {
          const aIndex = gridStats.has(a) ? 0 : 1;
          const bIndex = gridStats.has(b) ? 0 : 1;
          if (aIndex !== bIndex) return aIndex - bIndex;
          return a.localeCompare(b);
        });

        for (const [stat, val] of sorted) {
          const formatted = flatStats.has(stat) ? `+${val}` : `+${val}%`;
          output += `${stat}: ${formatted}\n`;
        }

        if (notes.length > 0) {
          output += `\nExtra Effects:\n${notes.join("\n")}`;
        }
      }

      bonusOutput.textContent = output.trim();

      // ðŸ”§ THIS IS THE FIX: Trigger collectable set evaluation
      const levels = window.getCollectableLevels?.();
      if (levels) evaluateCollectableSets(levels);
    }

    filteredCollectables.forEach(col => {
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.flexDirection = 'column';
      wrapper.style.alignItems = 'center';
      wrapper.style.textAlign = 'center';
      wrapper.style.fontSize = '12px';

      const img = document.createElement('img');
      img.src = col.icon;
      img.alt = "";
      img.style.width = '40px';
      img.style.height = '40px';
      img.style.marginBottom = '4px';

      const label = document.createElement('label');
      label.textContent = col.name;

      const select = document.createElement('select');
      select.id = `collectable${col.id}`;
      levels.forEach(level => {
        const option = document.createElement('option');
        option.value = level;
        option.textContent = level || '--';
        select.appendChild(option);
      });

      select.addEventListener('change', updateBonuses);

      wrapper.appendChild(img);
      wrapper.appendChild(label);
      wrapper.appendChild(select);
      grid.appendChild(wrapper);
    });

    updateBonuses();

    window.getCollectableLevels = function () {
      const result = {};
      filteredCollectables.forEach(col => {
        result[col.name] = document.getElementById(`collectable${col.id}`).value;
      });
      return result;
    };
  });

  function evaluateCollectableSets(collectableLevels) {
    const debugOutput = document.getElementById("collectableSetDebug");
    if (!window.collectableSets) {
      debugOutput.textContent = "Collectable sets not loaded.";
      return;
    }

    let output = "Collectable Set Bonuses Debug:\n\n";

    Object.entries(collectableSets).forEach(([setName, { members, bonuses }]) => {
      const starLevels = {};
      members.forEach(name => {
        starLevels[name] = collectableLevels[name] || '';
      });

      const totalStars = members.reduce((sum, name) => {
        const match = (starLevels[name] || '').match(/([YR])(\d)/);
        return sum + (match ? parseInt(match[2]) : 0);
      }, 0);

      const goldStars = members.reduce((sum, name) => {
        const level = starLevels[name] || '';
        const yellowMap = {
          'Y1': 1, 'Y2': 2, 'Y3': 3, 'Y4': 4, 'Y5': 5,
          'R1': 5, 'R2': 5, 'R3': 5, 'R4': 5, 'R5': 5
        };
        return sum + (yellowMap[level] || 0);
      }, 0);

      const redStars = members.reduce((sum, name) => {
        const match = (starLevels[name] || '').match(/R(\d)/);
        return sum + (match ? parseInt(match[1]) : 0);
      }, 0);

      output += `Set: ${setName}\n`;

      bonuses.forEach(bonus => {
        const { type, stat } = bonus;

        if (type === "perItemThreshold") {
          const allMeet = Object.entries(bonus.requiredStars || {}).every(([name, min]) => {
            const current = starLevels[name];
            if (!current) return false;
            const order = ["Y1", "Y2", "Y3", "Y4", "Y5", "R1", "R2", "R3", "R4", "R5"];
            return order.indexOf(current) >= order.indexOf(min);
          });

          if (allMeet) {
            const val = bonus.value || bonus.valuePercent || bonus.valuePerStack;
            const suffix = bonus.valuePercent || bonus.valuePerStack ? "%" : "";
            output += `âœ“ ${bonus.note || stat}: +${val}${suffix}\n`;
          }
        } else if (type === "totalStarThreshold") {
          let count = 0;
          if (bonus.starType === "yellow") count = goldStars;
          else if (bonus.starType === "red") count = redStars;
          else count = totalStars;

          if (count >= bonus.minStars) {
            const val = bonus.value || bonus.valuePercent;
            const suffix = bonus.valuePercent ? "%" : "";
            output += `âœ“ ${stat}: +${val}${suffix} (${count} ${bonus.starType} stars)\n`;
          }
        }
      });

      output += `â†’ Stars: Total=${totalStars}, Gold=${goldStars}, Red=${redStars}\n\n`;
    });

    debugOutput.textContent = output.trim();
  }
</script>



<!-- ========== Gear  ========== -->
<script src="gear.js"></script>
<section>
  <h2>Gear Bonuses</h2>
  <div id="gearGrid" style="
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 10px;
  "></div>
  <pre id="gearBonusOutput" style="background: #111; color: #0f0; padding: 10px; white-space: pre-wrap; min-height: 100px; margin-top: 10px;"></pre>
</section>

<script>
  const gearSlots = [
    { slot: 'Weapon', options: ['Twin Lance'] },
    { slot: 'Body Armor', options: ['EvervoidArmor', 'eChest'] },
    { slot: 'Necklace', options: ['judgmentNecklace', 'vNeck'] },
    { slot: 'Belt', options: ['stardustSash'] },
    { slot: 'Gloves', options: ['moonscarBracer'] },
    { slot: 'Boots', options: ['glacialWarboots', 'vBoots'] }
  ];
  const gridStats = new Set([
  "atk", "def", "hp",
  "critRate", "critDamage", "skillDamage",
  "bonusVsPoisoned", "bonusVsWeakened", "bonusVsChilled",
  "bonusVsLacerated", "bonusVsVulnerable", "bonusVsShielded"
  ]);
  const flatStats = new Set([
  "hpFlat", "atkFlat", "defFlat", "finalHP", "finalATK", "finalDEF", "moveSpeed"
  ]);
  const levelOptions = (prefix, max) => {
    const opts = [{ value: '', text: '--' }];
    for (let i = 1; i <= max; i++) opts.push({ value: prefix + i, text: prefix + i });
    return opts;
  };

  const bonusRegex = /([+\-]?[0-9]+(?:\.[0-9]+)?)(%)?/g;

  const grid = document.getElementById('gearGrid');

  gearSlots.forEach(({ slot, options }, index) => {
    const wrapper = document.createElement('div');
    wrapper.innerHTML = `<label><strong>${slot}</strong></label><br>`;

    const selector = document.createElement('select');
    selector.id = `gearSelect${index}`;
    options.forEach(key => {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = gearData[key]?.name || key;
      selector.appendChild(option);
    });

    const eSelect = document.createElement('select');
    eSelect.id = `eLevel${index}`;
    levelOptions('E', 5).forEach(o => {
      const opt = document.createElement('option');
      opt.value = o.value;
      opt.textContent = o.text;
      eSelect.appendChild(opt);
    });
    eSelect.value = 'E1';

    const vSelect = document.createElement('select');
    vSelect.id = `vLevel${index}`;
    levelOptions('V', 5).forEach(o => {
      const opt = document.createElement('option');
      opt.value = o.value;
      opt.textContent = o.text;
      vSelect.appendChild(opt);
    });
    vSelect.value = 'V1';

    const cSelect = document.createElement('select');
    cSelect.id = `cLevel${index}`;
    levelOptions('C', 10).forEach(o => {
      const opt = document.createElement('option');
      opt.value = o.value;
      opt.textContent = o.text;
      cSelect.appendChild(opt);
    });
    cSelect.value = 'C1';

    const aSelect = document.createElement('select');
    aSelect.id = `aLevel${index}`;
    levelOptions('A', 3).forEach(o => {
      const opt = document.createElement('option');
      opt.value = o.value;
      opt.textContent = o.text;
      aSelect.appendChild(opt);
    });
    aSelect.value = 'A1';

    const selects = [selector, eSelect, vSelect, cSelect, aSelect];
    selects.forEach(s => {
      wrapper.appendChild(s);
      wrapper.appendChild(document.createElement('br'));
    });

    grid.appendChild(wrapper);

    selector.addEventListener('change', () => updateGearDropdowns(index));
    selects.forEach(s => s.addEventListener('change', calculateGearBonuses));
  });

  function updateGearDropdowns(index) {
    const gearKey = document.getElementById(`gearSelect${index}`).value;
    const item = gearData[gearKey];

    document.getElementById(`eLevel${index}`).style.display = item?.eternalForge ? '' : 'none';
    document.getElementById(`vLevel${index}`).style.display = item?.voidForge ? '' : 'none';
    document.getElementById(`cLevel${index}`).style.display = (item?.chaosForge || item?.chaosFusion) ? '' : 'none';
    document.getElementById(`aLevel${index}`).style.display = item?.astralForge ? '' : 'none';

    calculateGearBonuses();
  }

  function parseBonuses(text) {
    const bonuses = {};
    const lines = text.split('\n');
    lines.forEach(line => {
      if (!line.includes('+')) return;

      (line.match(bonusRegex) || []).forEach(match => {
        const number = parseFloat(match);
        const type = line.toLowerCase().replace(match, '').replace(':', '').trim();
        if (!type) return;
        if (!bonuses[type]) bonuses[type] = 0;
        bonuses[type] += number;
      });
    });
    return bonuses;
  }

  function calculateGearBonuses() {
    const totalBonuses = {};

    gearSlots.forEach((_, index) => {
      const gearKey = document.getElementById(`gearSelect${index}`).value;
      const item = gearData[gearKey];
      if (!item) return;

      const bonuses = [];
      const e = document.getElementById(`eLevel${index}`).value;
      const v = document.getElementById(`vLevel${index}`).value;
      const c = document.getElementById(`cLevel${index}`).value;
      const a = document.getElementById(`aLevel${index}`).value;

      if (item.baseStats) {
        for (const [stat, val] of Object.entries(item.baseStats)) {
          bonuses.push(`${stat}: ${val}`);
        }
      }

      if (item.eternalForge && item.eternalForge[e]) bonuses.push(item.eternalForge[e]);
      if (item.voidForge && item.voidForge[v]) bonuses.push(item.voidForge[v]);
      if (item.chaosForge && item.chaosForge[c]) bonuses.push(item.chaosForge[c]);
      if (item.chaosFusion?.powers) {
        const cLevel = parseInt(c.replace('C', '')) || 0;
        for (const [lvl, bonus] of Object.entries(item.chaosFusion.powers)) {
          if (parseInt(lvl) <= cLevel) bonuses.push(bonus);
        }
      }
      if (item.astralForge && item.astralForge[a]) bonuses.push(item.astralForge[a]);

      const parsed = parseBonuses(bonuses.join('\n'));
      for (const [key, val] of Object.entries(parsed)) {
        if (!totalBonuses[key]) totalBonuses[key] = 0;
        totalBonuses[key] += val;
      }
    });

    const sorted = Object.entries(totalBonuses).sort(([a], [b]) => {
      const aIndex = gridStats.has(a) ? 0 : 1;
      const bIndex = gridStats.has(b) ? 0 : 1;
      if (aIndex !== bIndex) return aIndex - bIndex;
      return a.localeCompare(b);
    });

    const out = sorted.map(([stat, val]) => {
      const formatted = flatStats.has(stat) ? `+${val}` : `+${val}%`;
      return `${stat}: ${formatted}`;
    }).join('\n');
    document.getElementById('gearBonusOutput').textContent = out || 'No bonuses selected';
  }

  // Initialize dropdown visibility
  gearSlots.forEach((_, index) => updateGearDropdowns(index));
</script>


</body>
</html>
